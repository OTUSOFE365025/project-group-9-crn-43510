ADD Iteration 2 — 7 ADD Steps

This iteration follows the same ADD steps as Iteration 1:

1. Review Input
2. Establish Iteration Goal by Selecting Drivers
3. Choose System Elements to Decompose
4. Choose Design Concepts to Satisfy Drivers
5. Instantiate Subcomponents and Define Interfaces
6. Sketch Views and Record Design Decisions
7. Analyze the Design Against the Iteration Goal

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Step 1 — Review Input

  We revisited requirements with a focus on the subsystems affecting personalization, security, performance, and integration reliability. 
  This included reviewing quality attributes, external system constraints, and use cases requiring fine-grained behavior.

Step 2 — Establish Iteration Goal by Selecting Drivers

  This iteration targets the four qualities below, and the goal is to refine the subsystems with the highest dependence on these qualities:
  
    - Security & privacy (user data, roles, SSO)
    - Interoperability (external system dependencies)
    - Modifiability (AI models & external APIs change frequently)
    - Usability (personalized responses, reminders, multi-language support)

Step 3 — Choose System Elements to Decompose

  We selected four subsystems for refinement, of which all interact very closely with important quality attributes:
  
    - NLU / AI subsystem
    - Integration subsystem
    - User profile & personalization subsystem
    - Notification subsystem

Step 4 — Choose Design Concepts to Satisfy Drivers

  These concepts/choices directly carry out processes involving reliability, modifiability, and privacy needs.
  
    - Internal subcomponents inside each subsystem
    - Caching for NLU speed
    - Retry/circuit breaker patterns inside integrations
    - Scheduling + message queues for notifications
    - Data isolation in profile service
    - Versioned AI model deployment
  
Step 5 — Instantiate Subcomponents & Define Interfaces
  
  5.1 NLU / AI Subsystem
      - Internal Components
      - Intent Classifier
      - Entity Extractor
      - Language Detector
      - Model Server
      - Cache Layer
  
  5.2 Integration Subsystem
    - Internal Components
    - LMS Adapter
    - Registration Adapter
    - Calendar Adapter
    - Email Adapter
    - Error Handler
    - Retry Queue
  
  5.3 User Profile & Personalization
    - Internal Components
    - Profile Store
    - Preferences Manager
    - History Manager
    - Personalization Engine
  
  5.4 Notification Subsystem
    - Internal Components
    - Event Scheduler
    - Message Queue
    - Announcement Dispatcher
    - Email & Push Drivers

Step 6 — Sketch Views & Record Design Decisions

  Subsystem Diagrams to Include
    - NLU Internal
    - Integrations Internal
    - Profile System
    - Notification System
    - Domain Model
  
  Entities:
    - User
    - Course
    - Event
    - Announcement
    - ConversationHistory
    - Notification
    - Preferences
    - AnalyticsRecord
  
  Relationships:
    - User ↔ Courses (many-to-many)
    - User → ConversationHistory (one-to-many)
    - Course → Announcements (one-to-many)
    - User → Notifications (one-to-many)

Step 7 — Analyze the Design Against the Iteration Goal

  This refinement improved:
    - Security: clean boundaries around personal data
    - Modifiability: AI and integrations can be updated easily
    - Resilience: retry logic helps when external systems fail
    - User experience: personalization and reminders improve usability
  This ADD Iteration 2 process we completed was successful with stability and efficiency.
