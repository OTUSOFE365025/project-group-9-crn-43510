Attribute-Driven Design (ADD) is a step-by-step way to design an architecture starting from using requirements and quality attributes, 
instead of directly start with low-level code or classes. In this tutorial assignment we are completing 1 iteration of the ADD Process for the cash register system. 
ADD Process Iteration Steps: 
1. Review Input: Examine the use cases, quality attributes, and constraints for this iteration. 
2. Establish iteration goal by selecting drivers 
3. Choose one or more elements of the system to decompose 
4. Choose one or more design concepts that satisfy the selected drivers 
5. Instantiate architectural elements, allocate responsibilities and define interfaces 
6. Sketch views and record design decisions 
7. Perform analysis of current design and review iteration goal and design objectives 
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------

1. Introduction

  The first iteration focuses on shaping the overall structure of the AI-Powered Digital Assistant Platform (AIDAP). 
  Our aim here is simply to understand what the system must support and to outline an architectural direction that can realistically handle those needs. 
  At this stage, we are not trying to perfect details or refine interaction patterns. Instead, we are laying out the major components, choosing the architectural style, 
  and showing how everything fits together at a high level.

Step 1 — Review Input

  We began by reviewing Deliverable 1, which includes AIDAP’s use cases, quality attributes, and constraints. 
  This helped us understand what the system must accomplish and what limits we must work within. The main themes that emerged were:

    - Users need conversational access to many academic systems
    - The assistant must work quickly and reliably
    - There are strict security/privacy expectations
    - The platform needs to integrate with multiple existing systems (LMS, registration, calendars, email)
    - The university requires cloud deployment and SSO authentication
    - This early review framed the rest of the architectural work.

Step 2 — Establish Iteration Goal by Selecting Drivers

  Functional Drivers
  
    - R1 (Conversational access):	Core purpose of the platform.
    - R3 (Integrations):	Most questions depend on LMS, registration, or calendar data.
    - R5 (AI interpretation):	Defines the complexity of backend AI/NLP.
    - R6 (Combine live + stored data):	Affects orchestration and data-access design.
  
  Quality Attribute Drivers
  
    - Performance (~2s):	Users expect a natural, chat-like system.
    - Availability (99.5%):	Must function reliably during busy periods.
    - Scalability (5,000+ users):	Essential for registration/exam seasons.
    - Security/Privacy:	Sensitive academic data must be protected.
    - Interoperability:	External systems use inconsistent APIs.
  
  Constraints
  
    - Cloud deployment:	Shapes how components run.
    - SSO support:	Requires authentication components.
    - Use standard APIs:	Affects integration-layer structure.
    - Secure data handling:	Affects storage and access boundaries.

These drivers guided the architecture’s structure and priorities.

Step 3 — Choose System Elements to Decompose

  For the first iteration, we decomposed the system in a very general and wide-range method. The goal was to identify major components early so we can refine them later. 
  The main elements broken down were:
  
  - Conversational/UI layer
  - NLU/AI layer
  - Response orchestration layer
  - Integration layer
  - User profile/personalization layer
  - Notification services
  - Authentication/supporting infrastructure
  - Data storage
  
  This step showed us the initial “shape” of the system.

Step 4 — Choose Design Concepts to Satisfy Drivers

  To support the drivers chosen earlier, we selected several architectural concepts:
  
    - Microservices architecture:
        Each major subsystem becomes an independently scalable service.
    - API Gateway:
        Centralized routing, SSO validation, and rate limiting.
    - Event-driven messaging:
        Helps handle scheduled reminders and long-running tasks asynchronously.
    - Cloud-native deployment:
        Allows auto-scaling, load balancing, and managed storage.
    - Separation of concerns:
        Keeps AI logic independent from integrations and data storage.
    
  These concepts ensure the architecture can scale, stay secure, and evolve over time.

Step 5 — Instantiate Architectural Elements & Assign Responsibilities

  - API Gateway: Handles authentication, routing, and request throttling.
  - Conversational UI: Responsible for user-facing functionality.
  - NLU / AI Service: Handles intent recognition, entity extraction, and language processing.
  - Response Orchestrator: Decides which services to call.
  - User Profile Service: Stores preferences, conversation history, and personalization.
  - Integration Services: Connect to LMS, registration, calendar, email.
  - Notification Service: Manages reminders and announcements.
  - SSO Authentication Layer: Processes institutional login.
  - Data Storage Layer: SQL + NoSQL.
  - Monitoring/Logging: Tracks performance and system health.
Each component has a narrow responsibility to simplify maintenance and scaling.

Step 6 — Sketch Views & Record Design Decisions

  High-Level Architecture Diagram 
  *Image in File

  Deployment Diagram
  *Image in File

  Deployment View

    - Cloud environment with load-balanced API gateway
    - Service cluster running microservices with auto-scaling
    - SQL + NoSQL storage cluster
    - External connectors to LMS, registration, calendar, and email systems
    - AI/NLU and orchestration services horizontally scalable
  
  Key Decisions
  
    - Microservices chosen for modularity and scaling
    - API gateway chosen for unified access control
    - Adapters chosen to handle inconsistent external APIs
    - Mix of SQL + NoSQL chosen for flexibility

Step 7 — Analyze the Design Against the Iteration Goal

  The architecture provides:
    - Sufficient scalability
    - Strong availability characteristics
    - Clean modular boundaries
    - Compatibility with SSO
    - Flexibility for long-term updates
  The ADD Iteration 1 Process was succesfully and stably completed.
